---
title: "[영리한 프로그래밍을 위한 알고리즘] Section2) 순환"
layout: post
date: 2018-04-21 16:53
image: /assets/images/markdown.jpg
headerImage: false
tag:
- Algorithm
- 영리한 프로그래밍을 위한 알고리즘
- 강의노트
star: false
category: blog
categories: Algorithm
author: Dan
description: 영리한 프로그래밍을 위한 알고리즘
---

## 1. 순환(Recursion)의 개념과 기본 예제

### 1) Recursion은 항상 무한루프에 빠질까?
* 항상 무한루프에 빠지는 것은 아님
* 무한루프에 빠지지 않으려면?
  -   Base case: 적어도 하나의 Recursion에 빠지지 않는 경우가 존재
  -  Recursion case: resursion을 반복하다 보면 결국 base case로 수렴

#### 예제1) Factorial: n!

* 기본 개념
{% highlight raw %}
- 0! = 1
- n! = n * (n-1)!   (n > 0)
{% endhighlight %}

* 예제 코드
   {% highlight java %}
   public static int Factorial(int n)
   {
        if (n == 0)
          return 1;
        else
           return n*Factorial(n-1);
   }
   {% endhighlight %}


#### 예제2) X의 n승

* 기본 개념
{% highlight raw %}
    - x^0 = 1
    - x^n = x * x^(n-1)   (n > 0)
{% endhighlight %}

 * 예제 코드
   {% highlight java %}
   public static double power(double x, int n)
   {
       if (n == 0)
        return 1;
       else
        return x * power(x, n-1);
   }
   {% endhighlight %}


#### 예제3) Fibonacci Number

* 기본 개념
{% highlight raw %}
    - f(0) = 0
    - f(1) = 1
    - f(n) = f(n-1) + f(n-2)   (n > 1)
{% endhighlight %}

* 예제 코드
     {% highlight java %}
     public int Fibonacci (int n)
     {
       if (n < 2)
        return n;
       else
        return Fibonacci(n-2) + Fibonacci(n-1);
     }
     {% endhighlight %}


#### 예제4) 최대공약수: Euclid Method

   * 기본 개념
   {% highlight raw %}
    - m >= n인 두 양의 정수 m과 n에 대해 m이 n의 배수이면 gcd(m, n) = n이고, 그렇지 않으면 gcd(m, n) = gcd(n, m%n)이다.
{% endhighlight %}

  * 예제 코드
     {% highlight java %}
     public static double gcd (int m, int n)
     {
       if (m < n)
      {
          int tmp = m; m = n; n = tmp;
      }

      if (m%n == 0)
        return n;
      else
        return gcd(n, m%n);
     }
     {% endhighlight %}



#### 예제5) 최대공약수: Euclid Method 좀 더 단순한 버전

* 기본 개념
{% highlight raw %}
      - gcd(p, q) = p (q  = 0)
      - gcd(p, q) = gcd(q, p%q)
{% endhighlight %}

* 예제 코드
{% highlight java %}
public static double gcd (int m, int n)
{
 if (q == 0)
   return p;
 else
   return gcd(q, p%q);
}
{% endhighlight %}

---
### 2) Recursive Thinking

#### 예제1) 문자열의 길이 계산

* 기본 개념
{% highlight raw %}
한 문자열의 길이는 다른 어떤 문자열의 길이 + 1 이다.
{% endhighlight %}

* 알고리즘
{% highlight raw %}
if the string is empty
  return 0;
else
  return 1 plus the length of the string that
      excludes the first character;
{% endhighlight %}

* 소스 코드
{% highlight java %}
public static int length (String str)
{
  if (str.equals(""))
    return 0;
  else
    return 1 + length(str.substring(1));
}
{% endhighlight %}


#### 예제2) 문자열의 프린트

* 소스 코드
{% highlight java %}
public static void printChars(String str)
{
  if (str.length() == 0)
    return;
  else
  {
    System.out.print(str.charAt(0));
    printChars(str.substring(1));
  }
}
{% endhighlight %}


#### 예제3) 문자열을 뒤집어 프린트

* 기본 개념
{% highlight raw %}
어떠한 문자열을 뒤집어 프린트 하려면,
(1) 먼저 문자열에서 첫글자를 뺀 문자열을 뒤집어 프린트한 후,
(2) 마지막으로 첫글자를 프린트한다.
{% endhighlight %}

* 소스 코드
{% highlight java %}
public static void printCharReverse(String str)
{
  if (str.length() == 0)
    return;
  else
  {
    printCharReverse(str.substring(1));
    System.out.print(str.charAt(0)); // 예제2)의 코드에서 문장 순서가 바뀜
  }
}
{% endhighlight %}



#### 예제4) 2진수로 변환하여 출력

* 소스 코드
{% highlight java %}
// 음이 아닌 정수 n을 이진수로 변환하여 출력
public static void printInBinary(int n)
{
  if (n < 2)
    System.out.print(n);
  else
  {
    printInBinary(n/2); // n을 2로 나눈 몫을 먼저 2진수로 변환하여 출력한 후,
    System.out.print(n%2); // n을 2로 나눈 나머지를 출력
  }
}
{% endhighlight %}


#### 예제5) 배열의 합 구하기

* 소스 코드
{% highlight java %}
// data[0] 에서 data[n-1]까지의 합을 구하여 반환한다.
public static int sum(int n, int [] data)
{
  if (n <= 0)
    return 0;
  else
    return sum(n-1, data) + data[n-1];
}
{% endhighlight %}


#### 예제6) 데이터파일로부터 n개의 정수 읽어오기

* 소스 코드
{% highlight java %}
// scanner in이 참조하는 파일로부터 n개의 정수를 입력 받아
   배열 data의 data[0] ... data[n-1]에 저장한다.
public static void readFrom(int n, int [] data, scanner in)
{
  if (n == 0)
    return;
 else
{
    readFrom(n-1, data, in);
    data[n-1] = in.nextInt();
}
}
{% endhighlight %}


#### Recursion vs. Iteration

* 모든 순환함수는 반복문(Iteration)으로 변경 가능
* 그 역도 성립. 즉, 모든 반복문은 recursion으로 표현 가능
* 순환함수는 복잡한 알고리즘을 단순하고 알기 쉽게 표현하게 함
* 하지만 함수 호출에 따른 오버헤드가 있음(매개변수 전달, 액티베이션 프레임 생성 등)
